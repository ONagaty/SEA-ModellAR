/**
 * <copyright>
 *
 * Copyright (c) Continental Engineering Services and others. http://www.conti-engineering.com All rights reserved.
 *
 * File created by uidl6458 Oct 9, 2009 1:13:23 PM </copyright>
 */
package eu.cessar.ct.runtime.ecuc.internal.model;

import java.text.MessageFormat;
import java.util.*;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.runtime.Assert;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.sphinx.emf.util.EObjectUtil;

import eu.cessar.ct.core.mms.EResourceUtils;
import eu.cessar.ct.core.mms.EcucMetaModelUtils;
import eu.cessar.ct.core.mms.IMetaModelService;
import eu.cessar.ct.core.mms.IModelChangeMonitor;
import eu.cessar.ct.core.mms.MMSRegistry;
import eu.cessar.ct.core.mms.MetaModelUtils;
import eu.cessar.ct.core.mms.PostBuildPreferencesAccessor;
import eu.cessar.ct.core.mms.ecuc.IBSWModuleDescription;
import eu.cessar.ct.core.mms.splittable.SplitableUtils;
import eu.cessar.ct.core.platform.util.IModelChangeStampProvider;
import eu.cessar.ct.core.platform.util.Node;
import eu.cessar.ct.core.platform.util.PlatformUtils;
import eu.cessar.ct.core.platform.util.StringUtils;
import eu.cessar.ct.core.platform.util.Tree;
import eu.cessar.ct.runtime.ecuc.IEcucModel;
import eu.cessar.ct.runtime.ecuc.internal.CessarPluginActivator;
import eu.cessar.ct.runtime.ecuc.internal.sea.IGIdentifiableFilter;
import eu.cessar.ct.runtime.ecuc.internal.sea.SeaFiltersFactory;
import eu.cessar.ct.runtime.ecuc.util.*;
import eu.cessar.ct.sdk.IPostBuildContext;
import eu.cessar.ct.sdk.utils.ModelUtils;
import eu.cessar.ct.sdk.utils.SplitUtils;
import eu.cessar.req.Requirement;
import gautosar.gecucdescription.GConfigReferenceValue;
import gautosar.gecucdescription.GContainer;
import gautosar.gecucdescription.GModuleConfiguration;
import gautosar.gecucdescription.GParameterValue;
import gautosar.gecucparameterdef.GChoiceContainerDef;
import gautosar.gecucparameterdef.GChoiceReferenceDef;
import gautosar.gecucparameterdef.GConfigParameter;
import gautosar.gecucparameterdef.GConfigReference;
import gautosar.gecucparameterdef.GContainerDef;
import gautosar.gecucparameterdef.GModuleDef;
import gautosar.gecucparameterdef.GParamConfContainerDef;
import gautosar.gecucparameterdef.GReferenceDef;
import gautosar.ggenericstructure.ginfrastructure.GARPackage;
import gautosar.ggenericstructure.ginfrastructure.GIdentifiable;

/**
 *
 */
public class EcucModelImpl implements IEcucModel
{

	private static final String TRACE_TEMPLATE = "EcucModel [{0}] : {1}"; //$NON-NLS-1$

	/**
	 * A tree with all module definitions that exists inside a project and the corresponding packages.
	 */
	private Tree<EcucEntry> moduleDefModel;

	/**
	 * Holds the statuses potentially generated by model preparation (various errors can arise).
	 */
	private List<IStatus> initPMStatus;

	/**
	 * A tree with all module configurations that exists inside a project and the corresponding packages.
	 */
	private Tree<EcucEntry> moduleCfgModel;

	/**
	 * A sorted by key map between modules definitions qualified names and the moduleDefModel tree nodes. The data of
	 * the node is actually of type {@link GModuleDefEcucEntry}
	 */
	private Map<String, Node<EcucEntry>> moduleDefQNameMap;

	/**
	 * A mapping between module definitions and the list of the available BSW Module Descriptions
	 */
	private Map<GModuleDef, List<IBSWModuleDescription>> bswModuleDescriptionMap;

	/**
	 * A sorted by key map between modules configurations qualified names and the moduleCfgModel tree nodes. The data of
	 * the node is actually of type {@link GModuleCfgEcucEntry}
	 */
	private Map<String, Node<EcucEntry>> moduleCfgQNameMap;

	/**
	 * A collection with all resources from the current model that contain module definitions
	 */
	private Collection<Resource> resourcesWithModuleDefs;

	/**
	 * A collection with all resources from the current model that contain module configurations
	 */
	private Collection<Resource> resourcesWithModuleCfgs;

	/**
	 * A collection with all resources from the current model
	 */
	private Collection<Resource> allResources;

	private final IProject project;

	private boolean loading;

	private volatile boolean fullyInitialized;

	private IMetaModelService mmService;

	/**
	 * @param project
	 */
	public EcucModelImpl(IProject project)
	{
		this.project = project;
		mmService = MMSRegistry.INSTANCE.getMMService(project);
		initPMStatus = new ArrayList<IStatus>();
	}

	/**
	 * Initialize the model if necessary
	 */
	private void initModel()
	{
		// if init not complete, enter init block, wait if currently initializing or setting to null
		if (!fullyInitialized)
		{
			synchronized (this)
			{
				// test again if initialized
				if (!fullyInitialized)
				{
					loading = true;
					try
					{
						if (moduleDefModel == null)
						{
							runInitModel();
							fullyInitialized = true;
						}
					}
					finally
					{
						loading = false;
					}
				}
			}
		}
	}

	/**
	 * @param enabled
	 * @param string
	 */
	private void traceEvent(boolean enabled, String message)
	{
		if (enabled)
		{
			String projectName = project == null ? "null" : project.getName(); //$NON-NLS-1$

		}
	}

	/**
	 * @param enabled
	 * @param message
	 * @param args
	 */
	private void traceEvent(boolean enabled, String message, Object... args)
	{
		if (enabled)
		{
			String msg = MessageFormat.format(message, args);
			traceEvent(enabled, msg);
		}
	}

	/**
	 * initialize the model, shall be executed only by initModel
	 */
	private void runInitModel()
	{
		traceEvent(CessarPluginActivator.DBG_MODEL_LOADING, "Initialize model"); //$NON-NLS-1$
		// re-initialize the MMService just in case the MM has been changed
		mmService = MMSRegistry.INSTANCE.getMMService(project);
		Collection<Resource> resources = EResourceUtils.getProjectResources(project);
		if (CessarPluginActivator.DBG_MODEL_LOADING)
		{
			// trace the resources
			for (Resource res: resources)
			{
				traceEvent(true, "Loading resource {0}", res.getURI()); //$NON-NLS-1$
			}
		}
		runInitModuleDefModel(resources);
		runInitBSWModuleDescrModel(resources);
		runInitModuleCfgModel(resources);
		allResources = Collections.unmodifiableCollection(resources);
	}

	/**
	 * @param resources
	 */
	private void runInitBSWModuleDescrModel(Collection<Resource> resources)
	{
		bswModuleDescriptionMap = new HashMap<GModuleDef, List<IBSWModuleDescription>>();
		EClass bswEClass = mmService.getEcucMMService().getBSWModuleDescriptionClass();
		List<?> list = EObjectUtil.getAllInstancesOf(resources, bswEClass.getInstanceClass(), false);
		for (Object object: list)
		{
			IBSWModuleDescription wrapper = mmService.getEcucMMService().getBSWModuleDescriptionWrapper(
				(EObject) object);
			List<IBSWModuleDescription> bswList;
			if (bswModuleDescriptionMap.containsKey(wrapper.getModuleDefinition()))
			{
				bswList = bswModuleDescriptionMap.get(wrapper.getModuleDefinition());
			}
			else
			{
				bswList = new ArrayList<IBSWModuleDescription>();
				bswModuleDescriptionMap.put(wrapper.getModuleDefinition(), bswList);
			}
			bswList.add(wrapper);
		}
	}

	/**
	 * Initialize the moduleDef model
	 */
	private void runInitModuleDefModel(Collection<Resource> resources)
	{
		Tree<EcucEntry> newModel = new Tree<EcucEntry>();
		newModel.setRootElement(new Node<EcucEntry>(EcucEntry.ROOT));
		List<GModuleDef> allModuleDefs = EObjectUtil.getAllInstancesOf(resources, GModuleDef.class, false);
		Map<String, Node<EcucEntry>> newModules = new TreeMap<String, Node<EcucEntry>>();
		Collection<Resource> moduleDefsColl = new HashSet<Resource>();
		for (GModuleDef module: allModuleDefs)
		{
			Node<EcucEntry> moduleEntry = getModuleDefEntry(newModel, module);
			if (moduleEntry != null)
			{
				String qName = MetaModelUtils.getAbsoluteQualifiedName(module);
				newModules.put(qName, moduleEntry);
				Resource res = module.eResource();
				if (res != null)
				{
					moduleDefsColl.add(res);
				}
			}
		}
		resourcesWithModuleDefs = Collections.unmodifiableCollection(moduleDefsColl);
		moduleDefModel = newModel;
		moduleDefQNameMap = newModules;
	}

	/**
	 * Initialize the moduleCfg model
	 */
	private void runInitModuleCfgModel(Collection<Resource> resources)
	{
		Tree<EcucEntry> newModel = new Tree<EcucEntry>();
		newModel.setRootElement(new Node<EcucEntry>(EcucEntry.ROOT));
		List<GModuleConfiguration> allModuleCfgs = EObjectUtil.getAllInstancesOf(resources, GModuleConfiguration.class,
			false);
		Map<String, Node<EcucEntry>> newModules = new TreeMap<String, Node<EcucEntry>>();
		Collection<Resource> moduleCfsColl = new HashSet<Resource>();
		for (GModuleConfiguration module: allModuleCfgs)
		{
			// process it only if is not a preconfigured or recommended
			if (doIsRegularConfiguration(module))
			{
				Node<EcucEntry> moduleEntry = getModuleCfgEntry(newModel, module);
				if (moduleEntry != null)
				{
					String qName = MetaModelUtils.getAbsoluteQualifiedName(module);
					newModules.put(qName, moduleEntry);
					Resource res = module.eResource();
					if (res != null)
					{
						moduleCfsColl.add(res);
					}
				}
			}
		}
		resourcesWithModuleCfgs = Collections.unmodifiableCollection(moduleCfsColl);
		moduleCfgModel = newModel;
		moduleCfgQNameMap = newModules;
	}

	/**
	 * Create a new entry for the <code>module</code> GModuleDef.
	 *
	 * @param rootElement
	 * @param module
	 */
	@Requirement(
		reqID = "REQ_GENERATION#1")
	private Node<EcucEntry> getModuleDefEntry(Tree<EcucEntry> treeModel, GModuleDef module)
	{
		EObject object = module.eContainer();
		if (!(object instanceof GARPackage))
		{
			CessarPluginActivator.getDefault().logError("Got a (ignored) ModuleDef without a package {0}", //$NON-NLS-1$
				module);
			return null;
		}
		GARPackage ownerPackage = (GARPackage) object;
		GModuleDefEcucEntry moduleEntry = new GModuleDefEcucEntry(module);
		Node<EcucEntry> parentPackageEntry = getPackageEntry(treeModel, ownerPackage);
		Node<EcucEntry> result = locateModuleWithName(parentPackageEntry.getChildren(), module.gGetShortName(),
			GModuleDefEcucEntry.class);
		String qName = MetaModelUtils.getAbsoluteQualifiedName(module);
		if (result != null)
		{
			traceEvent(CessarPluginActivator.DBG_MODEL_LOADING_MODULE_DEF,
				"Module Def ignored (duplicate) : {0} from {1}", qName, module.eResource()); //$NON-NLS-1$

			String msg = "Multiple definitions for module with fully qualified name: " + qName; //$NON-NLS-1$

			CessarPluginActivator.getDefault().logWarning(msg);
			IStatus status = new Status(IStatus.ERROR, CessarPluginActivator.PLUGIN_ID, msg, new RuntimeException(msg));
			initPMStatus.add(status);
		}
		else
		{
			result = new Node<EcucEntry>(moduleEntry);
			parentPackageEntry.addChild(result);
			traceEvent(CessarPluginActivator.DBG_MODEL_LOADING_MODULE_DEF, "Module Def loaded : {0} from {1}", qName, //$NON-NLS-1$
				module.eResource());
		}
		return result;
	}

	/**
	 * Create a new entry for the <code>module</code> GModuleConfiguration.
	 *
	 * @param rootElement
	 * @param module
	 */
	private Node<EcucEntry> getModuleCfgEntry(Tree<EcucEntry> treeModel, GModuleConfiguration module)
	{
		EObject object = module.eContainer();
		if (!(object instanceof GARPackage))
		{
			CessarPluginActivator.getDefault().logError("Got a (ignored) ModuleDef without a package {0}", //$NON-NLS-1$
				module);
			return null;
		}
		GARPackage ownerPackage = (GARPackage) object;
		Node<EcucEntry> parentPackageEntry = getPackageEntry(treeModel, ownerPackage);
		Node<EcucEntry> result = locateModuleWithName(parentPackageEntry.getChildren(), module.gGetShortName(),
			GModuleCfgEcucEntry.class);
		String qName = MetaModelUtils.getAbsoluteQualifiedName(module);
		if (result != null)
		{
			GModuleCfgEcucEntry entry = (GModuleCfgEcucEntry) result.getData();
			entry.addModuleConfiguration(module);
			traceEvent(CessarPluginActivator.DBG_MODEL_LOADING_MODULE_CFG, "Module Cfg loaded : {0} from {1}", qName, //$NON-NLS-1$
				module.eResource());
		}
		else
		{
			GModuleCfgEcucEntry moduleEntry = new GModuleCfgEcucEntry(module);
			result = new Node<EcucEntry>(moduleEntry);
			parentPackageEntry.addChild(result);
			traceEvent(CessarPluginActivator.DBG_MODEL_LOADING_MODULE_CFG, "Module Cfg loaded : {0} from {1}", qName, //$NON-NLS-1$
				module.eResource());
		}
		return result;
	}

	/**
	 * Locate the entry for the package entry ownerPackage inside the treeModel. Create one if necessary.
	 *
	 * @param treeModel
	 * @param ownerPackage
	 * @return
	 */
	private Node<EcucEntry> getPackageEntry(Tree<EcucEntry> treeModel, GARPackage ownerPackage)
	{
		Assert.isNotNull(ownerPackage);
		Node<EcucEntry> owner;
		EObject object = ownerPackage.eContainer();
		if (object instanceof GARPackage)
		{
			// locate the parent
			GARPackage parentPackage = (GARPackage) object;
			owner = getPackageEntry(treeModel, parentPackage);
		}
		else
		{
			// assume root package
			owner = treeModel.getRootElement();
		}
		List<Node<EcucEntry>> children = owner.getChildren();
		Node<EcucEntry> node = locateEntryWithName(children, GPackageEcucEntry.class, ownerPackage.gGetShortName());
		if (node == null)
		{
			node = new Node<EcucEntry>(new GPackageEcucEntry(ownerPackage));
			owner.addChild(node);
		}
		else
		{
			// add the package to the list
			GPackageEcucEntry data = (GPackageEcucEntry) node.getData();
			data.addPackage(ownerPackage);
		}
		return node;
	}

	/**
	 * Search inside nodeList for an package entry that have the same name as <code>packageName</code>. Return null if
	 * there is no such entry
	 *
	 * @param nodeList
	 * @param entryName
	 * @return
	 */
	private static Node<EcucEntry> locateEntryWithName(List<Node<EcucEntry>> nodeList,
		Class<? extends EcucEntry> entryClass, String entryName)
	{
		for (Node<EcucEntry> node: nodeList)
		{
			if (entryClass.isInstance(node.getData()))
			{
				if (node.getData().sameName(entryName))
				{
					return node;
				}

			}
		}
		// if we got here, we didn't found it
		return null;
	}

	/**
	 * Traverse <code>nodeList</code> and check if there is a package with a particular qualified name.
	 *
	 * @param nodeList
	 *        the starting list
	 * @param packageQName
	 *        a qualified name
	 * @return
	 */
	private static Node<EcucEntry> locatePackageWithQName(List<Node<EcucEntry>> nodeList, String packageQName)
	{
		String[] qName = MetaModelUtils.splitQualifiedName(packageQName);
		int index = 0;
		List<Node<EcucEntry>> children = nodeList;
		Node<EcucEntry> pack = null;
		while (index < qName.length)
		{
			String name = qName[index];
			pack = locateEntryWithName(children, GPackageEcucEntry.class, name);
			if (pack == null)
			{
				// not found, stop
				break;
			}
			else
			{
				// we can go deeper
				children = pack.getChildren();
				index++;
			}
		}
		return pack;
	}

	/**
	 * Search inside nodeList for a module entry that have the same name as <code>moduleName</code> and is of type
	 * <code>moduleType</code>. Return null if there is no such entry
	 *
	 * @param nodeList
	 * @param moduleName
	 * @return
	 */
	private static Node<EcucEntry> locateModuleWithName(List<Node<EcucEntry>> nodeList, String moduleName,
		Class<?> moduleType)
	{
		for (Node<EcucEntry> node: nodeList)
		{
			if (moduleType.isInstance(node.getData()))
			{
				if (node.getData().sameName(moduleName))
				{
					return node;
				}
			}
		}
		// if we got here, we didn't found it
		return null;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#modelChanged()
	 */
	public void modelChanged()
	{
		traceEvent(CessarPluginActivator.DBG_MODEL_LOADING, "Model changed"); //$NON-NLS-1$
		if (!loading && moduleDefModel != null)
		{
			synchronized (this)
			{
				if (!loading && moduleDefModel != null)
				{
					fullyInitialized = false;

					moduleDefModel = null;
					moduleDefQNameMap = null;
					moduleCfgModel = null;
					moduleCfgQNameMap = null;
					resourcesWithModuleCfgs = null;
					resourcesWithModuleDefs = null;
					bswModuleDescriptionMap = null;
					initPMStatus = new ArrayList<IStatus>();
				}
			}
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getAllResources()
	 */
	public Collection<Resource> getAllResources()
	{
		initModel();
		return allResources;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getResourcesWithModuleCfgs()
	 */
	public Collection<Resource> getResourcesWithModuleCfgs()
	{
		initModel();
		return resourcesWithModuleCfgs;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getResourcesWithModuleDefs()
	 */
	public Collection<Resource> getResourcesWithModuleDefs()
	{
		initModel();
		return resourcesWithModuleDefs;
	}

	/**
	 * /* (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getRootArPackagesWithModuleDefs()
	 */
	public Map<String, List<GARPackage>> getRootArPackagesWithModuleDefs()
	{
		initModel();
		List<Node<EcucEntry>> children = moduleDefModel.getRootElement().getChildren();
		Map<String, List<GARPackage>> result = new HashMap<String, List<GARPackage>>();
		for (Node<EcucEntry> node: children)
		{
			if (node.getData() instanceof GPackageEcucEntry)
			{
				GPackageEcucEntry data = (GPackageEcucEntry) node.getData();
				result.put(data.getPackageName(), data.getPackages());
			}
		}
		return result;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getRootArPackagesWithModuleConfigurations()
	 */
	public Map<String, List<GARPackage>> getRootArPackagesWithModuleConfigurations()
	{
		initModel();
		List<Node<EcucEntry>> children = moduleCfgModel.getRootElement().getChildren();
		Map<String, List<GARPackage>> result = new HashMap<String, List<GARPackage>>();
		for (Node<EcucEntry> node: children)
		{
			if (node.getData() instanceof GPackageEcucEntry)
			{
				GPackageEcucEntry data = (GPackageEcucEntry) node.getData();
				result.put(data.getPackageName(), data.getPackages());
			}
		}
		return result;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getAllModuleDefs()
	 */
	public List<GModuleDef> getAllModuleDefs()
	{
		initModel();
		List<GModuleDef> result = new ArrayList<GModuleDef>();
		Collection<Node<EcucEntry>> values = moduleDefQNameMap.values();
		for (Node<EcucEntry> node: values)
		{
			if (node.getData() instanceof GModuleDefEcucEntry)
			{
				GModuleDefEcucEntry data = (GModuleDefEcucEntry) node.getData();
				result.add(data.getModuleDefinition());
			}
		}
		return Collections.unmodifiableList(result);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getAllModuleConfigurations()
	 */
	public List<GModuleConfiguration> getAllModuleCfgs()
	{
		initModel();
		List<GModuleConfiguration> result = new ArrayList<GModuleConfiguration>();
		Collection<Node<EcucEntry>> values = moduleCfgQNameMap.values();
		for (Node<EcucEntry> node: values)
		{
			if (node.getData() instanceof GModuleCfgEcucEntry)
			{
				GModuleCfgEcucEntry data = (GModuleCfgEcucEntry) node.getData();
				result.addAll(data.getAllConfigurations());
			}
		}
		return Collections.unmodifiableList(result);
	}

	/**
	 * @param moduleDef
	 * @return
	 */
	private List<IBSWModuleDescription> doGetBSWModuleDescriptions(GModuleDef moduleDef)
	{
		List<IBSWModuleDescription> list = bswModuleDescriptionMap.get(moduleDef);
		if (list == null)
		{
			return Collections.emptyList();
		}
		else
		{
			return Collections.unmodifiableList(list);
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getBSWModuleDescriptions(gautosar.gecucparameterdef.GModuleDef)
	 */
	public List<IBSWModuleDescription> getBSWModuleDescriptions(GModuleDef moduleDef)
	{
		initModel();
		return doGetBSWModuleDescriptions(moduleDef);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * eu.cessar.ct.runtime.ecuc.IEcucModel#isPreconfiguredConfiguration(gautosar.gecucdescription.GModuleConfiguration)
	 */
	public boolean isPreconfiguredConfiguration(GModuleConfiguration config)
	{
		initModel();
		return doIsPreconfiguredConfiguration(config);
	}

	/**
	 * @param config
	 * @return
	 */
	private boolean doIsPreconfiguredConfiguration(GModuleConfiguration config)
	{
		if (config == null || config.gGetDefinition() == null)
		{
			return false;
		}
		List<IBSWModuleDescription> list = doGetBSWModuleDescriptions(config.gGetDefinition());
		for (IBSWModuleDescription descr: list)
		{
			if (descr.getPreconfiguredConfiguration() == config)
			{
				return true;
			}
		}
		return false;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * eu.cessar.ct.runtime.ecuc.IEcucModel#isRecommendedConfiguration(gautosar.gecucdescription.GModuleConfiguration)
	 */
	public boolean isRecommendedConfiguration(GModuleConfiguration config)
	{
		initModel();
		return doIsRecommendedConfiguration(config);
	}

	/**
	 * @param config
	 * @return
	 */
	private boolean doIsRecommendedConfiguration(GModuleConfiguration config)
	{
		if (config == null || config.gGetDefinition() == null)
		{
			return false;
		}
		List<IBSWModuleDescription> list = doGetBSWModuleDescriptions(config.gGetDefinition());
		for (IBSWModuleDescription descr: list)
		{
			if (descr.getRecommendedConfiguration() == config)
			{
				return true;
			}
		}
		return false;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#isRegularConfiguration(gautosar.gecucdescription.GModuleConfiguration)
	 */
	public boolean isRegularConfiguration(GModuleConfiguration config)
	{
		initModel();
		return doIsRegularConfiguration(config);
	}

	/**
	 * @param config
	 * @return
	 */
	private boolean doIsRegularConfiguration(GModuleConfiguration config)
	{
		if (config == null || config.gGetDefinition() == null)
		{
			return false;
		}
		List<IBSWModuleDescription> list = doGetBSWModuleDescriptions(config.gGetDefinition());
		for (IBSWModuleDescription descr: list)
		{
			if (descr.getPreconfiguredConfiguration() == config)
			{
				return false;
			}
			if (descr.getRecommendedConfiguration() == config)
			{
				return false;
			}
		}
		return true;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getArPackagesWithModuleDefs(java.lang.String)
	 */
	public Map<String, List<GARPackage>> getArPackagesWithModuleDefs(String ownerPackageQName)
	{
		String normalizedOwnerPackageQName = MetaModelUtils.normalizeQualifiedName(ownerPackageQName);
		if (normalizedOwnerPackageQName == null
			|| normalizedOwnerPackageQName.equals(MetaModelUtils.QNAME_SEPARATOR_STR))
		{
			return getRootArPackagesWithModuleDefs();
		}
		initModel();
		Node<EcucEntry> entry = locatePackageWithQName(moduleDefModel.getRootElement().getChildren(),
			normalizedOwnerPackageQName);
		if (entry == null)
		{
			// not found
			return Collections.emptyMap();
		}
		else
		{
			// collect all children of entry that are packages and return them
			Map<String, List<GARPackage>> result = new TreeMap<String, List<GARPackage>>();
			List<Node<EcucEntry>> children = entry.getChildren();
			for (Node<EcucEntry> node: children)
			{
				if (node.getData() instanceof GPackageEcucEntry)
				{
					GPackageEcucEntry data = (GPackageEcucEntry) node.getData();
					result.put(data.getPackageName(), data.getPackages());
				}
			}
			return result;
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getArPackagesWithModuleConfigurations(java.lang.String)
	 */
	public Map<String, List<GARPackage>> getArPackagesWithModuleCfgs(String ownerPackageQName)
	{
		String normalizedOwnerPackageQName = MetaModelUtils.normalizeQualifiedName(ownerPackageQName);
		if (normalizedOwnerPackageQName == null
			|| normalizedOwnerPackageQName.equals(MetaModelUtils.QNAME_SEPARATOR_STR))
		{
			return getRootArPackagesWithModuleConfigurations();
		}
		initModel();
		Node<EcucEntry> entry = locatePackageWithQName(moduleCfgModel.getRootElement().getChildren(),
			normalizedOwnerPackageQName);
		if (entry == null)
		{
			// not found
			return Collections.emptyMap();
		}
		else
		{
			// collect all children of entry that are packages and return them
			Map<String, List<GARPackage>> result = new TreeMap<String, List<GARPackage>>();
			List<Node<EcucEntry>> children = entry.getChildren();
			for (Node<EcucEntry> node: children)
			{
				if (node.getData() instanceof GPackageEcucEntry)
				{
					GPackageEcucEntry data = (GPackageEcucEntry) node.getData();
					result.put(data.getPackageName(), data.getPackages());
				}
			}
			return result;
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getSplitedPackagesWithModuleCfg(java.lang.String)
	 */
	public List<GARPackage> getSplitedPackagesWithModuleCfg(String packQName)
	{
		String normalizedPackQName = MetaModelUtils.normalizeQualifiedName(packQName);
		if (normalizedPackQName == null || normalizedPackQName.equals(MetaModelUtils.QNAME_SEPARATOR_STR))
		{
			return Collections.emptyList();
		}
		initModel();
		Node<EcucEntry> entry = locatePackageWithQName(moduleDefModel.getRootElement().getChildren(),
			normalizedPackQName);
		if (entry != null)
		{
			GPackageEcucEntry data = (GPackageEcucEntry) entry.getData();
			return Collections.unmodifiableList(data.getPackages());
		}
		return Collections.emptyList();
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getModuleDefs(java.lang.String)
	 */
	public List<GModuleDef> getModuleDefsFromPackage(String ownerPackageQName)
	{
		initModel();
		Node<EcucEntry> entry = locatePackageWithQName(moduleDefModel.getRootElement().getChildren(),
			ownerPackageQName);
		if (entry == null)
		{
			return Collections.emptyList();
		}
		else
		{
			// collect all children of entry that are modules and return them
			List<GModuleDef> result = new ArrayList<GModuleDef>();
			List<Node<EcucEntry>> children = entry.getChildren();
			for (Node<EcucEntry> node: children)
			{
				if (node.getData() instanceof GModuleDefEcucEntry)
				{
					GModuleDefEcucEntry data = (GModuleDefEcucEntry) node.getData();
					result.add(data.getModuleDefinition());
				}
			}
			return Collections.unmodifiableList(result);
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getModuleConfigurations(java.lang.String)
	 */
	public List<GModuleConfiguration> getModuleCfgsFromPackage(String ownerPackageQName)
	{
		initModel();
		Node<EcucEntry> entry = locatePackageWithQName(moduleCfgModel.getRootElement().getChildren(),
			ownerPackageQName);
		if (entry == null)
		{
			return Collections.emptyList();
		}
		else
		{
			// collect all children of entry that are modules and return them
			List<GModuleConfiguration> result = new ArrayList<GModuleConfiguration>();
			List<Node<EcucEntry>> children = entry.getChildren();
			for (Node<EcucEntry> node: children)
			{
				if (node.getData() instanceof GModuleCfgEcucEntry)
				{
					GModuleCfgEcucEntry data = (GModuleCfgEcucEntry) node.getData();
					result.addAll(data.getAllConfigurations());
				}
			}
			return Collections.unmodifiableList(result);
		}
	}

	/**
	 * Return the module configurations that could contain the children with URI <code>childrenURI</code>
	 *
	 * @param childrenURI
	 * @return
	 */
	private static List<GModuleConfiguration> getModuleCfgsForChildren(List<Node<EcucEntry>> nodeList,
		String childrenURI)
	{
		String[] qName = MetaModelUtils.splitQualifiedName(childrenURI);
		int index = 0;
		List<Node<EcucEntry>> children = nodeList;
		Node<EcucEntry> pack = null;
		while (index < qName.length)
		{
			String name = qName[index];
			pack = locateEntryWithName(children, GPackageEcucEntry.class, name);
			if (pack != null)
			{
				// we can go deeper
				children = pack.getChildren();
				index++;
			}
			else
			{
				// not found, look for modulecfg
				pack = locateEntryWithName(children, GModuleCfgEcucEntry.class, name);
				if (pack != null)
				{
					return ((GModuleCfgEcucEntry) pack.getData()).getAllConfigurations();
				}
				break;
			}
		}
		return Collections.emptyList();
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getModuleConfigurations(gautosar.gecucparameterdef.GModuleDef)
	 */
	public Map<String, List<GModuleConfiguration>> getSplitedModuleCfgs(GModuleDef module)
	{
		initModel();
		Map<String, List<GModuleConfiguration>> result = new HashMap<String, List<GModuleConfiguration>>();
		for (String qName: moduleCfgQNameMap.keySet())
		{
			Node<EcucEntry> node = moduleCfgQNameMap.get(qName);
			GModuleCfgEcucEntry entry = (GModuleCfgEcucEntry) node.getData();
			List<GModuleConfiguration> partial = entry.getConfigurations(module);
			if (!partial.isEmpty())
			{
				result.put(qName, partial);
			}
		}
		return result;
	}

	public Map<GModuleDef, Map<String, List<GModuleConfiguration>>> getSplitedModuleCfgs(List<GModuleDef> moduleDefs)
	{
		initModel();

		Map<GModuleDef, Map<String, List<GModuleConfiguration>>> map = new HashMap<GModuleDef, Map<String, List<GModuleConfiguration>>>();
		// for each module, collect its configurations
		for (GModuleDef moduleDef: moduleDefs)
		{
			Map<String, List<GModuleConfiguration>> splitedModuleCfgs = getSplitedModuleCfgs(moduleDef);
			if (splitedModuleCfgs.size() > 0)
			{
				map.put(moduleDef, splitedModuleCfgs);
			}
		}
		return map;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getModuleDef(java.lang.String)
	 */
	public GModuleDef getModuleDef(String moduleDefQName)
	{
		initModel();
		String normalizedModuleDefQName = MetaModelUtils.normalizeQualifiedName(moduleDefQName);
		Node<EcucEntry> node = moduleDefQNameMap.get(normalizedModuleDefQName);
		if (node != null && node.getData() instanceof GModuleDefEcucEntry)
		{
			GModuleDefEcucEntry entry = (GModuleDefEcucEntry) node.getData();
			return entry.getModuleDefinition();
		}
		else
		{
			return null;
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getModuleConfiguration(java.lang.String)
	 */
	public List<GModuleConfiguration> getModuleCfg(String moduleCfgQName)
	{
		initModel();
		String normalizedModuleCfgQName = MetaModelUtils.normalizeQualifiedName(moduleCfgQName);
		Node<EcucEntry> node = moduleCfgQNameMap.get(normalizedModuleCfgQName);
		if (node != null && node.getData() instanceof GModuleCfgEcucEntry)
		{
			GModuleCfgEcucEntry entry = (GModuleCfgEcucEntry) node.getData();
			return entry.getAllConfigurations();
		}
		else
		{
			return Collections.emptyList();
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getModuleCfgs(gautosar.gecucparameterdef.GModuleDef)
	 */
	public List<GModuleConfiguration> getModuleCfgs(GModuleDef moduleDef)
	{
		initModel();

		GModuleDef unwrappedDef = SplitableUtils.INSTANCE.unWrapMergedObject(moduleDef);
		List<GModuleConfiguration> result = new ArrayList<GModuleConfiguration>();
		Collection<Node<EcucEntry>> values = moduleCfgQNameMap.values();
		for (Node<EcucEntry> node: values)
		{
			if (node.getData() instanceof GModuleCfgEcucEntry)
			{
				GModuleCfgEcucEntry data = (GModuleCfgEcucEntry) node.getData();
				List<GModuleConfiguration> cfgs = data.getAllConfigurations();
				for (GModuleConfiguration moduleCfg: cfgs)
				{
					if (moduleCfg.gGetDefinition() == unwrappedDef)
					{
						result.add(moduleCfg);
					}
				}
			}
		}
		return Collections.unmodifiableList(result);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getRefinedModules(gautosar.gecucparameterdef.GModuleDef)
	 */
	public List<GModuleDef> getRefinedModuleDefs(GModuleDef module)
	{
		initModel();

		if (module.gGetRefinedModuleDef() == null)
		{
			// fast return
			return Collections.emptyList();
		}
		else
		{
			List<GModuleDef> result = new ArrayList<GModuleDef>();
			GModuleDef parent = module.gGetRefinedModuleDef();
			while (parent != null)
			{
				// check for cycles, just to be sure....
				if (result.contains(parent))
				{
					CessarPluginActivator.getDefault().logError("Cycles detected for module {0}", module); //$NON-NLS-1$
					break;
				}
				result.add(parent);
				parent = parent.gGetRefinedModuleDef();
			}
			return result;
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getSplitedModuleConfigurations(gautosar.gecucdescription.
	 * GModuleConfiguration )
	 */
	public List<GModuleConfiguration> getSplitedModuleCfgs(GModuleConfiguration cfg)
	{
		String qualifiedName = ModelUtils.getAbsoluteQualifiedName(cfg);
		initModel();
		List<GModuleConfiguration> result = new ArrayList<GModuleConfiguration>();
		GModuleDef definition = cfg.gGetDefinition();
		if (definition != null)
		{
			for (Node<EcucEntry> node: moduleCfgQNameMap.values())
			{
				GModuleCfgEcucEntry entry = (GModuleCfgEcucEntry) node.getData();

				// result.addAll(entry.getConfigurations(definition));

				List<GModuleConfiguration> list = entry.getConfigurations(definition);
				for (GModuleConfiguration gmc: list)
				{
					if (ModelUtils.getAbsoluteQualifiedName(gmc).equals(qualifiedName))
					{
						if (gmc.eResource().equals(cfg.eResource()))
						{
							result.add(0, gmc);
						}
						else
						{
							result.add(gmc);
						}
					}
				}
			}
		}
		return result;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getModuleDefinition(gautosar.gecucparameterdef.GContainerDef)
	 */
	public GModuleDef getModuleDef(GContainerDef container)
	{
		if (container == null || container.eIsProxy())
		{
			return null;
		}
		EObject owner = container.eContainer();
		while (!(owner instanceof GModuleDef))
		{
			// starting with Autosar 4.2.2 the owner can be a EcucDestinationUriPolicy
			if (owner != null && owner.eClass().getName().equals("EcucDestinationUriPolicy")) //$NON-NLS-1$
			{
				return null;
			}
			if (owner == null)
			{
				// should not happen
				CessarPluginActivator.getDefault().logError(new Throwable(),
					"Got a container without a module definition: {0}", //$NON-NLS-1$
					container);
				return null;
			}
			owner = owner.eContainer();
		}
		return (GModuleDef) owner;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getModuleDef(gautosar.gecucparameterdef.GConfigParameter)
	 */
	public GModuleDef getModuleDef(GConfigParameter parameter)
	{
		if (parameter != null && parameter.eContainer() instanceof GContainerDef)
		{
			return getModuleDef((GContainerDef) parameter.eContainer());
		}
		else
		{
			return null;
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getModuleDef(gautosar.gecucparameterdef.GConfigReference)
	 */
	public GModuleDef getModuleDef(GConfigReference reference)
	{
		if (reference != null && reference.eContainer() instanceof GContainerDef)
		{
			return getModuleDef((GContainerDef) reference.eContainer());
		}
		else
		{
			return null;
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getModuleConfiguration(gautosar.gecucdescription.GContainer)
	 */
	public GModuleConfiguration getModuleCfg(GContainer container)
	{
		EObject owner = container.eContainer();
		while (!(owner instanceof GModuleConfiguration))
		{
			if (owner == null)
			{
				// should not happen
				CessarPluginActivator.getDefault().logError(new Throwable(),
					"Got a container without a module configuration: {0}", //$NON-NLS-1$
					container);
				return null;
			}
			owner = owner.eContainer();
		}
		return (GModuleConfiguration) owner;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getRefinedContainers(gautosar.gecucparameterdef.GContainerDef)
	 */
	public List<GIdentifiable> getRefinedContainerDefs(GContainerDef container)
	{
		if (container == null)
		{
			return Collections.emptyList();
		}
		initModel();
		GModuleDef moduleDef = getModuleDef(container);
		if (moduleDef == null)
		{
			// nothing more left to do, return an empty list, an error is
			// already logged
			return Collections.emptyList();
		}
		List<GModuleDef> refinedModules = getRefinedModuleDefs(moduleDef);
		String relativeQName = MetaModelUtils.getRelativeQName(moduleDef, container);

		List<GIdentifiable> refinements = new ArrayList<GIdentifiable>();
		for (GModuleDef refinedModule: refinedModules)
		{
			GIdentifiable relIdent = MetaModelUtils.getRelativeIdentifiables(refinedModule, relativeQName);
			// maybe log something if relIdent not of type GContainerDef
			refinements.add(relIdent);
		}
		return refinements;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getRefinedContainerDefFamily(gautosar.gecucparameterdef.GModuleDef,
	 * gautosar.gecucparameterdef.GContainerDef)
	 */
	public GContainerDef getRefinedContainerDefFamily(GModuleDef targetModule, GContainerDef refinedContainer)
	{
		GContainerDef localRefinedContainer = refinedContainer;
		/**
		 * If it is used with merged instance we need to extract concrete instance
		 */
		if (SplitUtils.isMergedInstace(refinedContainer))
		{
			Collection<GContainerDef> concreteInstances = SplitUtils.getConcreteInstances(refinedContainer);
			Iterator<GContainerDef> iterator = concreteInstances.iterator();
			if (iterator.hasNext())
			{
				localRefinedContainer = iterator.next();
			}
		}

		List<GIdentifiable> refinedContainerDefsFamily = getRefinedContainerDefsFamily(localRefinedContainer);
		for (GIdentifiable gIdentifiable: refinedContainerDefsFamily)
		{
			if (gIdentifiable instanceof GContainerDef)
			{
				GModuleDef gModuleDefOwner = getModuleDef((GContainerDef) gIdentifiable);
				if (gModuleDefOwner != null && gModuleDefOwner == targetModule)
				{
					return (GContainerDef) gIdentifiable;
				}
			}
		}
		return null;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getRefinedParameters(gautosar.gecucparameterdef.GConfigParameter)
	 */
	public List<GIdentifiable> getRefinedParameterDefs(GConfigParameter parameter)
	{
		initModel();
		EObject eContainer = parameter.eContainer();
		if (!(eContainer instanceof GParamConfContainerDef))
		{
			// this should not happen, log an error
			CessarPluginActivator.getDefault().logError("Got a parameter without a container {0}", //$NON-NLS-1$
				parameter);
			return Collections.emptyList();
		}
		GContainerDef owner = (GContainerDef) eContainer;
		String relativeQName = MetaModelUtils.getRelativeQName(owner, parameter);
		List<GIdentifiable> refinedContainers = getRefinedContainerDefs(owner);
		List<GIdentifiable> refinements = new ArrayList<GIdentifiable>();
		for (GIdentifiable refinedCnt: refinedContainers)
		{
			if (refinedCnt instanceof GParamConfContainerDef)
			{
				// be sure that is of the right type
				GIdentifiable relIdent = MetaModelUtils.getRelativeIdentifiables(refinedCnt, relativeQName);
				// maybe log something if relIdent not of type GContainerDef
				refinements.add(relIdent);
			}
		}
		return refinements;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getRefinedParameterDefFamily(gautosar.gecucparameterdef.GModuleDef,
	 * gautosar.gecucparameterdef.GConfigParameter)
	 */
	public GConfigParameter getRefinedParameterDefFamily(GModuleDef targetModule, GConfigParameter refinedParameter)
	{
		if (refinedParameter == null || refinedParameter.eContainer() == null)
		{
			return null;
		}
		GContainerDef ownerContainerDef = getRefinedContainerDefFamily(targetModule,
			(GContainerDef) refinedParameter.eContainer());
		if (!(ownerContainerDef instanceof GParamConfContainerDef))
		{
			return null;
		}
		// lookup a reference with the same name as teh parameter in the new
		// container
		EList<GConfigParameter> parameters = ((GParamConfContainerDef) ownerContainerDef).gGetParameters();
		for (GConfigParameter gConfigParameter: parameters)
		{
			if (StringUtils.equals(gConfigParameter.gGetShortName(), refinedParameter.gGetShortName()))
			{
				return gConfigParameter;
			}
		}
		return null;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getRefinedReferences(gautosar.gecucparameterdef.GConfigReference)
	 */
	public List<GIdentifiable> getRefinedReferenceDefs(GConfigReference reference)
	{
		initModel();
		EObject eContainer = reference.eContainer();
		if (!(eContainer instanceof GParamConfContainerDef))
		{
			// this should not happen, log an error
			CessarPluginActivator.getDefault().logError("Got a reference without a container {0}", //$NON-NLS-1$
				reference);
			return Collections.emptyList();
		}
		GContainerDef owner = (GContainerDef) eContainer;
		String relativeQName = MetaModelUtils.getRelativeQName(owner, reference);
		List<GIdentifiable> refinedContainers = getRefinedContainerDefs(owner);
		List<GIdentifiable> refinements = new ArrayList<GIdentifiable>();
		for (GIdentifiable refinedCnt: refinedContainers)
		{
			if (refinedCnt instanceof GParamConfContainerDef)
			{
				// be sure that is of the right type
				GIdentifiable relIdent = MetaModelUtils.getRelativeIdentifiables(refinedCnt, relativeQName);
				// maybe log something if relIdent not of type GContainerDef
				refinements.add(relIdent);
			}
		}
		return refinements;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getRefinedReferenceDefFamily(gautosar.gecucparameterdef.GModuleDef,
	 * gautosar.gecucparameterdef.GConfigReference)
	 */
	public GConfigReference getRefinedReferenceDefFamily(GModuleDef targetModule, GConfigReference refinedReference)
	{
		if (refinedReference.eContainer() == null)
		{
			return null;
		}
		GContainerDef ownerContainerDef = getRefinedContainerDefFamily(targetModule,
			(GContainerDef) refinedReference.eContainer());
		if (!(ownerContainerDef instanceof GParamConfContainerDef))
		{
			return null;
		}
		// lookup a reference with the same name as teh parameter in the new
		// container
		EList<GConfigReference> references = ((GParamConfContainerDef) ownerContainerDef).gGetReferences();
		for (GConfigReference gConfigReference: references)
		{
			if (StringUtils.equals(gConfigReference.gGetShortName(), refinedReference.gGetShortName()))
			{
				return gConfigReference;
			}
		}
		return null;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getRefinedContainerDef(gautosar.gecucparameterdef.GConfigReference,
	 * gautosar.gecucdescription.GContainer)
	 */
	public GContainerDef getRefinedContainerDef(GConfigReference definition, GContainer instance)
	{
		List<? extends GContainerDef> candidates;
		if (definition instanceof GChoiceReferenceDef)
		{
			candidates = ((GChoiceReferenceDef) definition).gGetDestinations();
		}
		else
		{ // it's a simple or symbolic reference def
			GContainerDef refDestination = ((GReferenceDef) definition).gGetRefDestination();
			if (refDestination != null && !refDestination.eIsProxy())
			{
				candidates = Collections.singletonList(refDestination);
			}
			else
			{
				candidates = Collections.EMPTY_LIST;
			}
		}
		GContainerDef targetDef = instance.gGetDefinition();
		if (candidates.contains(targetDef))
		{
			return targetDef;
		}
		else
		{
			List<GIdentifiable> family = getRefinedContainerDefsFamily(targetDef);
			for (GContainerDef candidate: candidates)
			{
				if (family.contains(candidate))
				{
					return candidate;
				}
			}
			return null;
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#collectContainers(gautosar.gecucparameterdef.GModuleDef)
	 */
	public List<GContainerDef> collectContainerDefs(GModuleDef module)
	{
		initModel();
		List<GModuleDef> refinedModuleDefs = getRefinedModuleDefs(module);
		List<GContainerDef> result = new ArrayList<GContainerDef>();
		result.addAll(module.gGetContainers());
		for (GModuleDef refinedModule: refinedModuleDefs)
		{
			EList<? extends GContainerDef> containers = refinedModule.gGetContainers();
			for (GContainerDef gContainerDef: containers)
			{
				if (MetaModelUtils.getIdentifiableIndex(result, gContainerDef.gGetShortName()) == -1)
				{
					// add it to the result
					result.add(gContainerDef);
				}
			}
		}
		return result;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#collectContainers(gautosar.gecucparameterdef.GContainerDef)
	 */
	public List<GContainerDef> collectContainerDefs(GContainerDef container)
	{
		initModel();
		List<GIdentifiable> refinedContainers = getRefinedContainerDefs(container);
		List<GContainerDef> result = new ArrayList<GContainerDef>();
		boolean isChoice = container instanceof GChoiceContainerDef;
		Class<?> containerClass;
		if (isChoice)
		{
			result.addAll(((GChoiceContainerDef) container).gGetChoices());
			containerClass = GChoiceContainerDef.class;
		}
		else
		{
			result.addAll(((GParamConfContainerDef) container).gGetSubContainers());
			containerClass = GParamConfContainerDef.class;
		}
		for (GIdentifiable refinedContainer: refinedContainers)
		{
			if (containerClass.isInstance(refinedContainer))
			{
				EList<? extends GContainerDef> containers;
				if (isChoice)
				{
					containers = ((GChoiceContainerDef) refinedContainer).gGetChoices();
				}
				else
				{
					containers = ((GParamConfContainerDef) refinedContainer).gGetSubContainers();
				}
				for (GContainerDef gContainerDef: containers)
				{
					if (MetaModelUtils.getIdentifiableIndex(result, gContainerDef.gGetShortName()) == -1)
					{
						// add it to the result
						result.add(gContainerDef);
					}
				}
			}
		}
		return result;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#collectMatchingContainerDefs(gautosar.gecucparameterdef.
	 * GParamConfContainerDef , java.lang.String)
	 */
	@Override
	public List<GContainerDef> collectMatchingContainerDefs(GContainerDef context, String pathFragment)
	{
		initModel();
		List<GContainerDef> collected = new ArrayList<GContainerDef>();

		accumulateMatchingContainerDefs(collected, context,
			SeaFiltersFactory.getFilterDefinitionByPathFragment(pathFragment, true));

		return collected;
	}

	/**
	 * Searches for container definitions inside the given <code> context</code>'s subtree (itself included), that make
	 * it through the <code>filter</code>, also collecting them in the given list.
	 *
	 * @param collected
	 *        list where to collect the matching container definitions
	 * @param context
	 *        container definition to be filtered together with its subtree
	 * @param filter
	 *        the filter to be used
	 */
	private void accumulateMatchingContainerDefs(List<GContainerDef> collected, GContainerDef context,
		IGIdentifiableFilter filter)
	{
		if (filter.isPassingFilter(context))
		{
			collected.add(context);
		}

		List<GContainerDef> children = new ArrayList<GContainerDef>();
		if (context instanceof GChoiceContainerDef)
		{
			children.addAll(((GChoiceContainerDef) context).gGetChoices());
		}
		else
		{
			children.addAll(((GParamConfContainerDef) context).gGetSubContainers());
		}

		for (GContainerDef child: children)
		{
			accumulateMatchingContainerDefs(collected, child, filter);
		}

	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#collectParameters(gautosar.gecucparameterdef.GParamConfContainerDef)
	 */
	public List<GConfigParameter> collectParameterDefs(GParamConfContainerDef container)
	{
		initModel();
		List<GIdentifiable> refinedContainers = getRefinedContainerDefs(container);
		List<GConfigParameter> result = new ArrayList<GConfigParameter>();
		for (GIdentifiable refinedContainer: refinedContainers)
		{
			if (refinedContainer instanceof GParamConfContainerDef)
			{
				EList<? extends GConfigParameter> parameters = ((GParamConfContainerDef) refinedContainer).gGetParameters();
				for (GConfigParameter gConfigParameter: parameters)
				{
					if (MetaModelUtils.getIdentifiableIndex(result, gConfigParameter.gGetShortName()) == -1)
					{
						result.add(gConfigParameter);
					}
				}
			}
		}
		return result;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#collectReferences(gautosar.gecucparameterdef.GParamConfContainerDef)
	 */
	public List<GConfigReference> collectReferenceDefs(GParamConfContainerDef container)
	{
		initModel();
		List<GIdentifiable> refinedContainers = getRefinedContainerDefs(container);
		List<GConfigReference> result = new ArrayList<GConfigReference>();
		for (GIdentifiable refinedContainer: refinedContainers)
		{
			if (refinedContainer instanceof GParamConfContainerDef)
			{
				EList<? extends GConfigReference> references = ((GParamConfContainerDef) refinedContainer).gGetReferences();
				for (GConfigReference gConfigReference: references)
				{
					if (MetaModelUtils.getIdentifiableIndex(result, gConfigReference.gGetShortName()) == -1)
					{
						result.add(gConfigReference);
					}
				}
			}
		}
		return result;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getSplitedContainersForContainerb(java.util.List,
	 * gautosar.gecucparameterdef.GContainerDef)
	 */
	public List<SplitedEntry<GContainer>> getSplitedContainersForContainer(List<GContainer> owners,
		GContainerDef definition)
	{
		initModel();
		GContainerDef unwrappedDef = SplitableUtils.INSTANCE.unWrapMergedObject(definition);
		if (unwrappedDef instanceof GChoiceContainerDef)
		{
			return getSplitedChoiceContainersForContainer(owners, (GChoiceContainerDef) unwrappedDef);
		}
		// LinkedHashMap<String, ESplitableList<GContainer>> result = new
		// LinkedHashMap<String, ESplitableList<GContainer>>();
		List<SplitedEntry<GContainer>> result = new ArrayList<SplitedEntry<GContainer>>();
		for (GContainer owner: owners)
		{
			Resource listSource = owner.eResource();
			EList<GContainer> list = owner.gGetSubContainers();
			for (GContainer candidate: list)
			{
				if (candidate.gGetDefinition() == unwrappedDef)
				{
					accumulateNamedContainers(result, list, candidate, unwrappedDef, listSource);
				}
			}
		}
		return result;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getSplitedContainersFromContainer(java.util.List,
	 * gautosar.gecucparameterdef.GContainerDef)
	 */
	@Override
	public List<SplitedEntry<GContainer>> getSplitedContainersFromContainer(List<GContainer> ancestors,
		GContainerDef definition)
	{
		initModel();

		GContainerDef unwrappedDef = SplitableUtils.INSTANCE.unWrapMergedObject(definition);

		List<SplitedEntry<GContainer>> result = new ArrayList<SplitedEntry<GContainer>>();

		if (unwrappedDef instanceof GChoiceContainerDef)
		{

			EList<GContainer> l = new BasicEList<GContainer>();
			l.addAll(ancestors);

			doCollectSplittedChoiceContainers(result, l, (GChoiceContainerDef) unwrappedDef);
		}
		else
		{

			for (GContainer ancestor: ancestors)
			{
				EList<GContainer> list = ancestor.gGetSubContainers();
				doCollectSplitedContainers(result, list, unwrappedDef);
			}
		}
		return result;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getSplitedContainersForModule(java.util.List,
	 * gautosar.gecucparameterdef.GContainerDef)
	 */
	public List<SplitedEntry<GContainer>> getSplitedContainersForModule(List<GModuleConfiguration> owners,
		GContainerDef definition)
	{
		initModel();
		GContainerDef unwrappedDef = SplitableUtils.INSTANCE.unWrapMergedObject(definition);
		if (unwrappedDef instanceof GChoiceContainerDef)
		{
			return getSplitedChoiceContainersForModule(owners, (GChoiceContainerDef) unwrappedDef);
		}
		// LinkedHashMap<String, ESplitableList<GContainer>> result = new
		// LinkedHashMap<String, ESplitableList<GContainer>>();
		List<SplitedEntry<GContainer>> result = new ArrayList<SplitedEntry<GContainer>>();
		for (GModuleConfiguration module: owners)
		{
			Resource listSource = module.eResource();
			EList<GContainer> list = module.gGetContainers();
			for (GContainer candidate: list)
			{
				if (candidate.gGetDefinition() == unwrappedDef)
				{
					accumulateNamedContainers(result, list, candidate, unwrappedDef, listSource);
				}
			}
		}
		return result;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getSplitedContainersFromModule(java.util.List,
	 * gautosar.gecucparameterdef.GContainerDef)
	 */
	public List<SplitedEntry<GContainer>> getSplitedContainersFromModule(List<GModuleConfiguration> owners,
		GContainerDef definition)
	{
		initModel();
		GContainerDef unwrappedDef = SplitableUtils.INSTANCE.unWrapMergedObject(definition);
		if (unwrappedDef instanceof GChoiceContainerDef)
		{
			return getSplitedChoiceContainersFromModule(owners, (GChoiceContainerDef) unwrappedDef);
		}

		List<SplitedEntry<GContainer>> result = new ArrayList<SplitedEntry<GContainer>>();
		for (GModuleConfiguration module: owners)
		{
			EList<GContainer> list = module.gGetContainers();

			doCollectSplitedContainers(result, list, unwrappedDef);
		}
		return result;
	}

	/**
	 * Parses the subtree of each candidate from <code>candidates</code> list, gathering under a {@link SplitedEntry}
	 * the containers that have the same definition as the provided one and also the same short name, and adding the
	 * entry to the <code>result</code> list. A depth-first search is performed.
	 *
	 * @param result
	 *        list where to collect the results
	 * @param candidates
	 *        container definitions whose subtree is to be parsed
	 * @param definition
	 *        definition
	 */
	private void doCollectSplitedContainers(List<SplitedEntry<GContainer>> result, EList<GContainer> candidates,
		GContainerDef definition)
	{
		for (GContainer candidate: candidates)
		{
			Resource listSource = candidate.eResource();
			if (candidate.gGetDefinition() == definition)
			{
				accumulateNamedContainers(result, candidates, candidate, definition, listSource);
			}
			else
			{
				String q1 = ModelUtils.getAbsoluteQualifiedName(candidate.gGetDefinition());
				String q2 = ModelUtils.getAbsoluteQualifiedName(definition);
				if (q2.startsWith(q1))
				{
					EList<GContainer> subContainers = candidate.gGetSubContainers();
					doCollectSplitedContainers(result, subContainers, definition);
				}
			}
		}
	}

	/**
	 * @param owners
	 * @param definition
	 * @return
	 */
	private static List<SplitedEntry<GContainer>> getSplitedChoiceContainersForContainer(List<GContainer> owners,
		GChoiceContainerDef definition)
	{
		// LinkedHashMap<String, ESplitableList<GContainer>> result = new
		// LinkedHashMap<String, ESplitableList<GContainer>>();
		List<SplitedEntry<GContainer>> result = new ArrayList<SplitedEntry<GContainer>>();
		for (GContainer container: owners)
		{
			Resource listSource = container.eResource();
			EList<GContainer> list = container.gGetSubContainers();
			for (GContainer candidate: list)
			{
				if (candidate.gGetDefinition() == null)
				{
					continue;
				}
				if (candidate.gGetDefinition() == definition)
				{
					// do not put this container but all it's childrens
					EList<GContainer> subCntList = candidate.gGetSubContainers();
					for (GContainer subCnt: subCntList)
					{
						accumulateNamedContainers(result, subCntList, subCnt, definition, listSource);
					}
				}
				else if (candidate.gGetDefinition().eContainer() == definition)
				{
					accumulateNamedContainers(result, list, candidate, definition, listSource);
				}
			}
		}
		return result;
	}

	/**
	 * @param owners
	 * @param definition
	 * @return
	 */
	private static List<SplitedEntry<GContainer>> getSplitedChoiceContainersForModule(List<GModuleConfiguration> owners,
		GChoiceContainerDef definition)
	{
		// LinkedHashMap<String, ESplitableList<GContainer>> result = new
		// LinkedHashMap<String, ESplitableList<GContainer>>();
		List<SplitedEntry<GContainer>> result = new ArrayList<SplitedEntry<GContainer>>();
		for (GModuleConfiguration module: owners)
		{
			Resource listSource = module.eResource();
			EList<GContainer> list = module.gGetContainers();
			for (GContainer candidate: list)
			{
				if (candidate.gGetDefinition() == null)
				{
					continue;
				}
				if (candidate.gGetDefinition() == definition)
				{
					// do not put this container but all it's childrens
					EList<GContainer> subCntList = candidate.gGetSubContainers();
					for (GContainer subCnt: subCntList)
					{
						accumulateNamedContainers(result, subCntList, subCnt, definition, listSource);
					}
				}
				else if (candidate.gGetDefinition().eContainer() == definition)
				{
					accumulateNamedContainers(result, list, candidate, definition, listSource);
				}
			}
		}
		return result;
	}

	/**
	 * @param owners
	 * @param definition
	 * @return
	 */
	private static List<SplitedEntry<GContainer>> getSplitedChoiceContainersFromModule(
		List<GModuleConfiguration> owners, GChoiceContainerDef definition)
	{
		List<SplitedEntry<GContainer>> result = new ArrayList<SplitedEntry<GContainer>>();
		for (GModuleConfiguration module: owners)
		{
			EList<GContainer> list = module.gGetContainers();
			doCollectSplittedChoiceContainers(result, list, definition);
		}
		return result;
	}

	/**
	 * Parses the subtree of each candidate from <code>candidates</code> list, gathering under a {@link SplitedEntry}
	 * the containers that have the same definition as the provided one and also the same short name, and adding the
	 * entry to the <code>result</code> list. A depth-first search is performed.
	 *
	 * @param result
	 *        list where to collect the results
	 * @param candidates
	 *        container definitions whose subtree is to be parsed
	 * @param definition
	 *
	 */
	private static void doCollectSplittedChoiceContainers(List<SplitedEntry<GContainer>> result,
		EList<GContainer> candidates, GChoiceContainerDef definition)
	{
		for (GContainer candidate: candidates)
		{
			Resource listSource = candidate.eResource();

			if (candidate.gGetDefinition() == null)
			{
				continue;
			}
			if (candidate.gGetDefinition() == definition)
			{
				// do not put this container but all it's childrens
				EList<GContainer> subCntList = candidate.gGetSubContainers();
				for (GContainer subCnt: subCntList)
				{
					accumulateNamedContainers(result, subCntList, subCnt, definition, listSource);
				}
			}
			else if (candidate.gGetDefinition().eContainer() == definition)
			{
				accumulateNamedContainers(result, candidates, candidate, definition, listSource);
			}
			else
			{
				String q1 = ModelUtils.getAbsoluteQualifiedName(candidate.gGetDefinition());
				String q2 = ModelUtils.getAbsoluteQualifiedName(definition);
				EList<GContainer> subContainers = candidate.gGetSubContainers();
				if (q2.startsWith(q1))
				{
					doCollectSplittedChoiceContainers(result, subContainers, definition);
				}
			}
		}
	}

	/**
	 *
	 * Accumulate in the <code>result</code> map all containers from the <code>owningList</code> that share the
	 * definition as <code>candidate</code> and the same name. The key of the map is the fully qualified name of a
	 * container and the value are all containers with that qualified name. The list is modifiable.
	 *
	 * @param result
	 * @param owningList
	 * @param candidate
	 */
	private static void accumulateNamedContainers(List<SplitedEntry<GContainer>> result, EList<GContainer> owningList,
		GContainer candidate, GContainerDef definition, Resource candidateSource)
	{
		String sName = candidate.gGetShortName();
		String qName = MetaModelUtils.getAbsoluteQualifiedName(candidate);
		SplitedEntry<GContainer> newSplittedEntry = new SplitedEntry<GContainer>();
		newSplittedEntry.setName(sName);
		newSplittedEntry.setQualifiedName(qName);
		IModelChangeStampProvider changeProvider = IModelChangeMonitor.INSTANCE.getChangeStampProvider(candidate);

		int indexOfPrevious = -1;

		if (sName == null || ("").equals(sName)) //$NON-NLS-1$
		{
			FixedSubEList<GContainer> fixedSubEList = new FixedSubEList<GContainer>(GContainer.class,
				new GContainer[] {candidate}, owningList, candidateSource, changeProvider);
			newSplittedEntry.setSplitableList(fixedSubEList);
			result.add(newSplittedEntry);
		}

		else
		{

			// ESplitableList<GContainer> containers = result.get(qName);
			ESplitableList<GContainer> containers = null;
			for (int i = 0; i < result.size(); i++)
			{
				SplitedEntry<GContainer> splitedEntry = result.get(i);
				String name = splitedEntry.getQualifiedName();
				if (name != null && name.equals(qName))
				{
					containers = splitedEntry.getSplitableList();
					indexOfPrevious = i;
					break;
				}
			}
			if (definition instanceof GParamConfContainerDef)
			{
				if (containers == null)
				{
					containers = new NamedParamConfContainerSubEList((GParamConfContainerDef) definition, sName,
						owningList, candidateSource, changeProvider);

					newSplittedEntry.setSplitableList(containers);
					result.add(newSplittedEntry);

				}
				else
				{
					if (containers instanceof NamedParamConfContainerSubEList)
					{
						NamedParamConfContainerSubEList previous = (NamedParamConfContainerSubEList) containers;

						// check source
						if ((candidateSource != null) && candidateSource.equals(previous.getSources().get(0)))
						{
							// same source
							// transform the previous list into a fixed list,
							// and replace it in the result
							FixedSubEList<GContainer> previousTransformed = new FixedSubEList<GContainer>(
								GContainer.class, new GContainer[] {previous.get(0)}, previous.getParentList(),
								previous.getSources().get(0), changeProvider);
							SplitedEntry<GContainer> newSplittedEntry1 = new SplitedEntry<GContainer>();
							newSplittedEntry1.setName(sName);
							newSplittedEntry1.setQualifiedName(qName);
							newSplittedEntry1.setSplitableList(previousTransformed);
							result.set(indexOfPrevious, newSplittedEntry1);

							// create a new fixed list for the current candidate
							// and add it in the result
							FixedSubEList<GContainer> newList = new FixedSubEList<GContainer>(GContainer.class,
								new GContainer[] {candidate}, owningList, candidateSource, changeProvider);
							newSplittedEntry.setSplitableList(newList);
							result.add(newSplittedEntry);
						}
						else
						{
							// different source
							// transform the previous list into a multi list
							// add the previous's parent list and the owning
							// list as parentLists
							NamedParamConfContainerMultiEList previousTransformed = new NamedParamConfContainerMultiEList(
								(GParamConfContainerDef) definition, sName, changeProvider);
							previousTransformed.addParentList(previous.getParentList(), previous.getSources().get(0));
							previousTransformed.addParentList(owningList, candidateSource);
							newSplittedEntry.setSplitableList(previousTransformed);
							result.set(indexOfPrevious, newSplittedEntry);

						}

					}
					else if (containers instanceof FixedSubEList)
					{
						FixedSubEList<GContainer> previous = (FixedSubEList<GContainer>) containers;

						// check source
						if ((candidateSource != null) && (candidateSource.equals(previous.getSources().get(0))))
						{
							// same source
							// leave the previous list
							// create a new fixed list for the current candidate
							// and add it in the result
							FixedSubEList<GContainer> newList = new FixedSubEList<GContainer>(GContainer.class,
								new GContainer[] {candidate}, owningList, candidateSource, changeProvider);
							newSplittedEntry.setSplitableList(newList);
							result.add(newSplittedEntry);
						}
						else
						{
							// different source
							// transform the previous list into a multi list
							// add the previous fixed list and the owning
							// list as parentLists
							NamedParamConfContainerMultiEList previousTransformed = new NamedParamConfContainerMultiEList(
								(GParamConfContainerDef) definition, sName, changeProvider);
							previousTransformed.addParentList(previous, previous.getSources().get(0));
							previousTransformed.addParentList(owningList, candidateSource);
							newSplittedEntry.setSplitableList(previousTransformed);
							result.set(indexOfPrevious, newSplittedEntry);
						}
					}
					else if (containers instanceof NamedParamConfContainerMultiEList)
					{
						NamedParamConfContainerMultiEList previous = (NamedParamConfContainerMultiEList) containers;
						// get the list that has the same source as the current
						// candidate
						EList<? super GContainer> parentListSameSource = null;
						if (candidateSource != null)
						{
							parentListSameSource = previous.getParentList(candidateSource);
						}

						if (parentListSameSource != null)
						{
							if (!(parentListSameSource instanceof FixedSubEList))
							{
								// transform the found list into a named one, to
								// be able to get after that, the container with
								// sName
								NamedParamConfContainerSubEList parentListSameSourceNamed = new NamedParamConfContainerSubEList(
									(GParamConfContainerDef) definition, sName, parentListSameSource, candidateSource,
									changeProvider);
								// transform the found list into a fixed list
								FixedSubEList<GContainer> parentListSameSourceTransformed = new FixedSubEList<GContainer>(
									GContainer.class, new GContainer[] {parentListSameSourceNamed.get(0)},
									parentListSameSource, candidateSource, changeProvider);
								// replace the transformed list in the multi
								// list
								int index = previous.getParentELists().indexOf(parentListSameSource);
								previous.getParentELists().set(index, parentListSameSourceTransformed);
							}
							// create a new fixed list for the current candidate
							// and add it in the result
							FixedSubEList<GContainer> newList = new FixedSubEList<GContainer>(GContainer.class,
								new GContainer[] {candidate}, owningList, candidateSource, changeProvider);
							newSplittedEntry.setSplitableList(newList);
							result.add(newSplittedEntry);
						}
						else
						{
							// different source
							// add to the existing multi list the owning list as
							// parent list
							previous.addParentList(owningList, candidateSource);
						}

					}

				}
			}

			else
			{ // definition is a choice container
				if (containers == null)
				{
					containers = new NamedChoiceContainerSubEList((GChoiceContainerDef) definition, sName, owningList,
						candidateSource, changeProvider);
					newSplittedEntry.setSplitableList(containers);
					result.add(newSplittedEntry);
				}
				else
				{
					if (containers instanceof NamedChoiceContainerSubEList)
					{
						NamedChoiceContainerSubEList previous = (NamedChoiceContainerSubEList) containers;

						// check source
						if (candidateSource.equals(previous.getSources().get(0)))
						{
							// same source
							// transform the previous list into a fixed list,
							// and replace it in the result
							FixedSubEList<GContainer> previousTransformed = new FixedSubEList<GContainer>(
								GContainer.class, new GContainer[] {previous.get(0)}, previous.getParentList(),
								previous.getSources().get(0), changeProvider);
							SplitedEntry<GContainer> newSplittedEntry1 = new SplitedEntry<GContainer>();
							newSplittedEntry1.setName(sName);
							newSplittedEntry1.setQualifiedName(qName);
							newSplittedEntry1.setSplitableList(previousTransformed);
							result.set(indexOfPrevious, newSplittedEntry1);

							// create a new fixed list for the current candidate
							// and add it in the result
							FixedSubEList<GContainer> newList = new FixedSubEList<GContainer>(GContainer.class,
								new GContainer[] {candidate}, owningList, candidateSource, changeProvider);
							newSplittedEntry.setSplitableList(newList);
							result.add(newSplittedEntry);
						}
						else
						{
							// different source
							// transform the previous list into a multi list
							// add the previous's parent list and the owning
							// list as parentLists
							NamedChoiceContainerMultiEList previousTransformed = new NamedChoiceContainerMultiEList(
								(GChoiceContainerDef) definition, sName, changeProvider);
							previousTransformed.addParentList(previous.getParentList(), previous.getSources().get(0));
							previousTransformed.addParentList(owningList, candidateSource);
							newSplittedEntry.setSplitableList(previousTransformed);
							result.set(indexOfPrevious, newSplittedEntry);

						}

					}
					else if (containers instanceof FixedSubEList)
					{
						FixedSubEList<GContainer> previous = (FixedSubEList<GContainer>) containers;

						// check source
						if (candidateSource.equals(previous.getSources().get(0)))
						{
							// same source
							// leave the previous list
							// create a new fixed list for the current candidate
							// and add it in the result
							FixedSubEList<GContainer> newList = new FixedSubEList<GContainer>(GContainer.class,
								new GContainer[] {candidate}, owningList, candidateSource, changeProvider);
							newSplittedEntry.setSplitableList(newList);
							result.add(newSplittedEntry);
						}
						else
						{
							// different source
							// transform the previous list into a multi list
							// add the previous fixed list and the owning
							// list as parentLists
							NamedChoiceContainerMultiEList previousTransformed = new NamedChoiceContainerMultiEList(
								(GChoiceContainerDef) definition, sName, changeProvider);
							previousTransformed.addParentList(previous, previous.getSources().get(0));
							previousTransformed.addParentList(owningList, candidateSource);
							newSplittedEntry.setSplitableList(previousTransformed);
							result.set(indexOfPrevious, newSplittedEntry);
						}
					}
					else if (containers instanceof NamedParamConfContainerMultiEList)
					{
						NamedChoiceContainerMultiEList previous = (NamedChoiceContainerMultiEList) containers;
						// get the list that has the same source as the current
						// candidate
						EList<? super GContainer> parentListSameSource = previous.getParentList(candidateSource);
						if (parentListSameSource != null)
						{
							if (!(parentListSameSource instanceof FixedSubEList))
							{
								// transform the found list into a named one, to
								// be able to get after that, the container with
								// sName
								NamedChoiceContainerSubEList parentListSameSourceNamed = new NamedChoiceContainerSubEList(
									(GChoiceContainerDef) definition, sName, parentListSameSource, candidateSource,
									changeProvider);
								// transform the found list into a fixed list
								FixedSubEList<GContainer> parentListSameSourceTransformed = new FixedSubEList<GContainer>(
									GContainer.class, new GContainer[] {parentListSameSourceNamed.get(0)},
									parentListSameSource, candidateSource, changeProvider);
								// replace the transformed list in the multi
								// list
								int index = previous.getParentELists().indexOf(parentListSameSource);
								previous.getParentELists().set(index, parentListSameSourceTransformed);
							}
							// create a new fixed list for the current candidate
							// and add it in the result
							FixedSubEList<GContainer> newList = new FixedSubEList<GContainer>(GContainer.class,
								new GContainer[] {candidate}, owningList, candidateSource, changeProvider);
							newSplittedEntry.setSplitableList(newList);
							result.add(newSplittedEntry);
						}
						else
						{
							// different source
							// add to the existing multi list the owning list as
							// parent list
							previous.addParentList(owningList, candidateSource);
						}

					}

				}
			}
		}

	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getSplitedSiblingContainers(gautosar.gecucdescription.GContainer)
	 */
	public ESplitableList<GContainer> getSplitedSiblingContainers(GContainer container)
	{
		initModel();
		GContainerDef definition = container.gGetDefinition();
		Resource candidateResource = container.eResource();
		EObject owner = container.eContainer();
		IModelChangeStampProvider changeProvider = IModelChangeMonitor.INSTANCE.getChangeStampProvider(container);
		if (!(owner instanceof GIdentifiable))
		{
			// if owner is invalid, or container not in a resource, no sibiling
			// containers will be found
			List<Object> sources = candidateResource == null ? Collections.emptyList()
				: Collections.singletonList((Object) candidateResource);
			return new ESplitableList.Unmodifiable<GContainer>(new GContainer[] {container}, false, sources);
		}
		else
		{
			GIdentifiable identOwner = (GIdentifiable) owner;
			String qName = MetaModelUtils.getAbsoluteQualifiedName(container);
			String shortName = container.gGetShortName();

			if (shortName == null || ("").equals(shortName)) //$NON-NLS-1$
			{
				// no sibiling containers will be valid for this case, even if
				// another containers with shortName=null or "" exist in
				// different resources
				FixedSubEList<GContainer> fixedSubEList = new FixedSubEList<GContainer>(GContainer.class,
					new GContainer[] {container}, EcucMetaModelUtils.getSubContainers(identOwner), candidateResource,
					changeProvider);
				return fixedSubEList;
			}

			// check for all the objects with the same qualified name as the
			// current container

			List<GModuleConfiguration> moduleCfgs = getModuleCfgsForChildren(
				moduleCfgModel.getRootElement().getChildren(), qName);

			List<EObject> objects = new ArrayList<EObject>();

			if (moduleCfgs.size() > 0)
			{
				if (moduleCfgs.size() == 1)
				{
					// improvement, for one module configuration basically we
					// have no splitable so there is only the current container
					// to process
					objects.add(container);
				}
				else
				{
					GModuleConfiguration moduleCfg = getModuleCfg(container);
					if (moduleCfg != null)
					{
						String relQName = MetaModelUtils.getRelativeQName(moduleCfg, container);

						for (GModuleConfiguration cfg: moduleCfgs)
						{
							GIdentifiable candidate = MetaModelUtils.getRelativeIdentifiables(cfg, relQName);
							if (candidate != null)
							{
								objects.add(candidate);
							}
						}
					}
				}
			}
			ESplitableList<GContainer> result = new FixedSubEList<GContainer>(GContainer.class,
				new GContainer[] {container}, EcucMetaModelUtils.getSubContainers(identOwner), candidateResource,
				changeProvider);

			if (objects.size() <= 1)
			{
				return result;
			}

			for (EObject currentObject: objects)
			{
				// skip the current one, that was already taken into account
				if (currentObject == container)
				{
					continue;
				}
				if (currentObject instanceof GContainer)
				{
					GContainer currentGContainer = (GContainer) currentObject;
					Resource currentResource = currentGContainer.eResource();
					if (((GContainer) currentObject).gGetDefinition().equals(definition))
					{
						// take into consideration only containers in a
						// different resource
						List<Object> sources = result.getSources();
						boolean resourceExisting = false;
						for (Object object: sources)
						{
							if (currentResource.equals(object))
							{
								resourceExisting = true;
								break;
							}
						}
						if (!resourceExisting)
						{
							EList<GContainer> currentOwningList = EcucMetaModelUtils.getSubContainers(
								currentGContainer.eContainer());

							// definition is a param conf container
							if (definition instanceof GParamConfContainerDef)
							{
								if (result instanceof NamedParamConfContainerMultiEList)
								{
									// add to the existing multi list the owning
									// list of the current container
									NamedParamConfContainerMultiEList previous = (NamedParamConfContainerMultiEList) result;
									previous.addParentList(currentOwningList, currentResource);
									result = previous;
								}
								else
								{
									// create a new multi list with parents
									// lists the owning list of the current
									// container and the previous fixed list
									NamedParamConfContainerMultiEList multiEList = new NamedParamConfContainerMultiEList(
										(GParamConfContainerDef) definition, shortName, changeProvider);
									if (result instanceof FixedSubEList)
									{
										FixedSubEList<GContainer> previous = (FixedSubEList<GContainer>) result;
										multiEList.addParentList(previous, currentResource);
									}
									multiEList.addParentList(currentOwningList, currentResource);
									result = multiEList;
								}
							}
							else
							{
								// definition is a choice container
								if (result instanceof NamedChoiceContainerMultiEList)
								{
									// add to the existing multi list the owning
									// list of the current container
									NamedChoiceContainerMultiEList previous = (NamedChoiceContainerMultiEList) result;
									previous.addParentList(currentOwningList, currentResource);
									result = previous;
								}
								else
								{
									// create a new multi list with parents
									// lists the owning list of the current
									// container and the previous fixed list
									NamedChoiceContainerMultiEList multiEList = new NamedChoiceContainerMultiEList(
										(GChoiceContainerDef) definition, shortName, changeProvider);
									multiEList.addParentList(currentOwningList, currentResource);

									if (result instanceof FixedSubEList)
									{
										FixedSubEList<GContainer> previous = (FixedSubEList<GContainer>) result;
										multiEList.addParentList(previous, currentResource);
									}
									result = multiEList;
								}
							}
						}

					}
				}

			}
			return result;
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getSplitedParameters(java.util.List, java.lang.Class,
	 * gautosar.gecucparameterdef.GConfigParameter)
	 */
	@Override
	public <T extends GParameterValue> ESplitableList<T> getSplitedParameters(List<GContainer> owners,
		Class<T> paramClass, GConfigParameter paramDef)
	{
		GConfigParameter unwrappedDef = SplitableUtils.INSTANCE.unWrapMergedObject(paramDef);
		IModelChangeStampProvider changeProvider = IModelChangeMonitor.INSTANCE.getChangeStampProvider(paramDef);
		if (owners.size() == 1)
		{
			return new ParameterValueSubEList<T>(paramClass, unwrappedDef, owners.get(0).gGetParameterValues(),
				owners.get(0).eResource(), changeProvider);
		}
		else
		{
			ParameterValueMultiEList<T> result = new ParameterValueMultiEList<T>(paramClass, unwrappedDef,
				changeProvider);
			for (GContainer container: owners)
			{
				result.addParentList(container.gGetParameterValues(), container.eResource());
			}
			return result;
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getSplitedReferences(java.util.List, java.lang.Class,
	 * gautosar.gecucparameterdef.GConfigReference)
	 */
	public <T extends GConfigReferenceValue> ESplitableList<T> getSplitedReferences(List<GContainer> owners,
		Class<T> paramClass, GConfigReference referenceDef)
	{
		GConfigReference unwrappedDef = SplitableUtils.INSTANCE.unWrapMergedObject(referenceDef);
		IModelChangeStampProvider changeProvider = IModelChangeMonitor.INSTANCE.getChangeStampProvider(referenceDef);
		if (owners.size() == 1)
		{
			return new ReferenceValueSubEList<T>(paramClass, unwrappedDef, owners.get(0).gGetReferenceValues(),
				owners.get(0).eResource(), changeProvider);
		}
		else
		{
			ReferenceValueMultiEList<T> result = new ReferenceValueMultiEList<T>(paramClass, unwrappedDef,
				changeProvider);
			for (GContainer container: owners)
			{
				result.addParentList(container.gGetReferenceValues(), container.eResource());
			}
			return result;
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * eu.cessar.ct.runtime.ecuc.IEcucModel#getMultipleConfigurationContainerDefs(gautosar.gecucparameterdef.GModuleDef)
	 */
	public List<GParamConfContainerDef> getMultipleConfigurationContainerDefs(GModuleDef moduleDef)
	{
		List<GParamConfContainerDef> multiConfigContainerDefs = new ArrayList<GParamConfContainerDef>();
		if (moduleDef != null)
		{
			EList<GContainerDef> containers = moduleDef.gGetContainers();
			for (GContainerDef gContainerDef: containers)
			{
				collectSubContainers(gContainerDef, multiConfigContainerDefs);
			}

		}
		return multiConfigContainerDefs;
	}

	/**
	 * @param gContainerDef
	 * @param result
	 */
	private void collectSubContainers(GContainerDef gContainerDef, List<GParamConfContainerDef> result)
	{
		EList<? extends GContainerDef> subContainers = null;
		if (gContainerDef instanceof GParamConfContainerDef)
		{
			if (mmService.getEcucMMService().isMultipleConfigurationContainer((GParamConfContainerDef) gContainerDef))
			{
				result.add((GParamConfContainerDef) gContainerDef);
			}
			subContainers = ((GParamConfContainerDef) gContainerDef).gGetSubContainers();
		}
		else if (gContainerDef instanceof GChoiceContainerDef)
		{
			subContainers = ((GChoiceContainerDef) gContainerDef).gGetChoices();
		}
		if (subContainers != null)
		{
			for (GContainerDef gSubContainerDef: subContainers)
			{
				collectSubContainers(gSubContainerDef, result);
			}
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getDescendedModules(gautosar.gecucparameterdef.GModuleDef)
	 */
	public List<GModuleDef> getRefiningModuleDefs(GModuleDef module)
	{
		if (module != null)
		{
			initModel();
			GModuleDef unwrappedModule = SplitableUtils.INSTANCE.unWrapMergedObject(module);
			List<GModuleDef> moduleDefs = getAllModuleDefs();
			// check which one of this modules have the module as refined
			List<GModuleDef> result = new ArrayList<GModuleDef>();
			for (GModuleDef potentialChild: moduleDefs)
			{
				if (potentialChild.gGetRefinedModuleDef() == unwrappedModule)
				{
					result.add(potentialChild);
				}
			}
			return result;
		}
		else
		{
			return Collections.emptyList();
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getAllRefiningModuleDefs(gautosar.gecucparameterdef.GModuleDef)
	 */
	public List<GModuleDef> getAllRefiningModuleDefs(GModuleDef module)
	{
		initModel();
		List<GModuleDef> result = new ArrayList<GModuleDef>();

		collectAllRefiningfModuleDefs(module, result);
		if (result.contains(null))
		{
			return null;
		}
		return result;
	}

	/**
	 * @param module
	 * @param result
	 */
	private void collectAllRefiningfModuleDefs(GModuleDef module, List<GModuleDef> result)
	{
		List<GModuleDef> defs = getRefiningModuleDefs(module);

		if (defs.isEmpty())
		{
			// do nothing
		}
		else
		{
			for (GModuleDef def: defs)
			{
				if (result.contains(def))
				{
					result.clear();
					result.add(null);
					CessarPluginActivator.getDefault().logError(
						"cycle detected at module: " + ModelUtils.getAbsoluteQualifiedName(def)); //$NON-NLS-1$
					return;
				}
				else
				{
					result.add(def);
					collectAllRefiningfModuleDefs(def, result);
				}
			}
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getModuleDefsFamily(gautosar.gecucparameterdef.GModuleDef)
	 */
	public List<GModuleDef> getRefinedModuleDefsFamily(GModuleDef module)
	{
		if (module == null)
		{
			return Collections.emptyList();
		}
		List<GModuleDef> result = new ArrayList<GModuleDef>();
		List<GModuleDef> refinedModuleDefs = getRefinedModuleDefs(module);
		for (int i = refinedModuleDefs.size() - 1; i >= 0; i--)
		{
			result.add(refinedModuleDefs.get(i));
		}
		result.add(module);
		List<GModuleDef> refiningModuleDefs = getAllRefiningModuleDefs(module);
		if (refiningModuleDefs != null)
		{
			result.addAll(refiningModuleDefs);
		}
		return result;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getContainerDefsFamily(gautosar.gecucdescription.GContainer)
	 */
	public List<GIdentifiable> getRefinedContainerDefsFamily(GContainerDef container)
	{
		if (container == null)
		{
			return Collections.emptyList();
		}
		List<GIdentifiable> result = new ArrayList<GIdentifiable>();

		List<GModuleDef> containingModuleDefs = getRefinedModuleDefsFamily(getModuleDef(container));

		for (GModuleDef def: containingModuleDefs)
		{
			String relativName = container.gGetShortName();
			EObject cont = container.eContainer();
			while (!(cont instanceof GModuleDef))
			{
				relativName = ((GIdentifiable) cont).gGetShortName() + "/" + relativName; //$NON-NLS-1$
				cont = cont.eContainer();
			}

			GIdentifiable famContainer = ModelUtils.getEObjectWithRelativeName(def, relativName);

			result.add(famContainer);
		}
		return result;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getRefiningContainerDefs(gautosar.gecucdescription.GContainer)
	 */
	public List<GIdentifiable> getRefiningContainerDefs(GContainerDef container)
	{
		if (container == null)
		{
			return Collections.emptyList();
		}
		List<GIdentifiable> result = new ArrayList<GIdentifiable>();
		List<GModuleDef> containingModuleDefs = getRefiningModuleDefs(getModuleDef(container));

		for (GModuleDef def: containingModuleDefs)
		{
			String relativName = container.gGetShortName();
			EObject cont = container.eContainer();
			while (!(cont instanceof GModuleDef))
			{
				relativName = ((GIdentifiable) cont).gGetShortName() + "/" + relativName; //$NON-NLS-1$
				cont = cont.eContainer();
			}

			GIdentifiable refiningContainer = ModelUtils.getEObjectWithRelativeName(def, relativName);
			result.add(refiningContainer);
		}
		return result;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getAllRefiningContainerDefs(gautosar.gecucdescription.GContainer)
	 */
	public List<GIdentifiable> getAllRefiningContainerDefs(GContainerDef container)
	{
		if (container == null)
		{
			return Collections.emptyList();
		}
		List<GIdentifiable> result = new ArrayList<GIdentifiable>();
		List<GModuleDef> containingModuleDefs = getAllRefiningModuleDefs(getModuleDef(container));

		if (containingModuleDefs == null)
		{
			return null;
		}
		else
		{
			for (GModuleDef def: containingModuleDefs)
			{
				String relativName = container.gGetShortName();
				EObject cont = container.eContainer();
				while (!(cont instanceof GModuleDef))
				{
					relativName = ((GIdentifiable) cont).gGetShortName() + "/" + relativName; //$NON-NLS-1$
					cont = cont.eContainer();
				}

				GIdentifiable refiningContainer = ModelUtils.getEObjectWithRelativeName(def, relativName);
				result.add(refiningContainer);
			}
			return result;
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getSplitedContainers(gautosar.gecucparameterdef.GContainerDef)
	 */
	public List<SplitedEntry<GContainer>> getSplitedContainers(GContainerDef containerDefinition)
	{
		if (containerDefinition == null)
		{
			return null;
		}

		List<SplitedEntry<GContainer>> containersForModule = new ArrayList<SplitedEntry<GContainer>>();

		GModuleDef moduleDef = getModuleDef(containerDefinition);

		Map<String, List<GModuleConfiguration>> splitedModuleCfgs = getSplitedModuleCfgs(moduleDef);
		Set<String> keySet = splitedModuleCfgs.keySet();
		for (String key: keySet)
		{
			List<GModuleConfiguration> list = splitedModuleCfgs.get(key);
			containersForModule.addAll(getSplitedContainersFromModule(list, containerDefinition));
		}
		return containersForModule;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getAllPostBuildContexts()
	 */
	public Map<IPostBuildContext, List<GContainer>> getAllPostBuildContexts(boolean includeNotUsed)
	{
		List<GModuleConfiguration> cfgs = getAllModuleCfgs();
		Map<IPostBuildContext, List<GContainer>> result = new HashMap<IPostBuildContext, List<GContainer>>();
		for (GModuleConfiguration cfg: cfgs)
		{
			Map<IPostBuildContext, List<GContainer>> contexts = getPostBuildContexts(cfg);
			for (Map.Entry<IPostBuildContext, List<GContainer>> context: contexts.entrySet())
			{
				IPostBuildContext key = context.getKey();
				List<GContainer> value = context.getValue();
				if (result.containsKey(key))
				{
					List<GContainer> list = result.get(key);
					list.addAll(value);
				}
				else
				{
					result.put(key, value);
				}
			}
		}
		if (includeNotUsed)
		{
			List<IPostBuildContext> postBuildContexts = PostBuildPreferencesAccessor.getPostBuildContexts(project);
			for (IPostBuildContext notUsedContext: postBuildContexts)
			{
				if (!result.containsKey(notUsedContext))
				{
					List<GContainer> emptyList = Collections.emptyList();
					result.put(notUsedContext, emptyList);
				}
			}
		}
		return result;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getPostBuildContexts(gautosar.gecucdescription.GModuleConfiguration)
	 */
	public Map<IPostBuildContext, List<GContainer>> getPostBuildContexts(GModuleConfiguration moduleCfg)
	{
		EList<GContainer> containers = moduleCfg.gGetContainers();
		Map<IPostBuildContext, List<GContainer>> result = new HashMap<IPostBuildContext, List<GContainer>>();
		for (GContainer container: containers)
		{
			populatePostBuildContexts(container, result);
		}
		return result;
	}

	/**
	 * @param container
	 * @param contexts
	 */
	private void populatePostBuildContexts(GContainer container, Map<IPostBuildContext, List<GContainer>> contexts)
	{
		GContainerDef definition = container.gGetDefinition();
		boolean pbSupport = false;
		if (definition != null && !definition.eIsProxy() && definition instanceof GParamConfContainerDef)
		{
			pbSupport = EcucMetaModelUtils.getPostBuildContextSupport(
				(GParamConfContainerDef) container.gGetDefinition());
		}
		if (pbSupport)
		{
			IPostBuildContext context = EcucMetaModelUtils.getPostBuildContext(container, false);
			if (context != null)
			{
				if (contexts.containsKey(context))
				{
					contexts.get(context).add(container);
				}
				else
				{
					List<GContainer> containers = new ArrayList<GContainer>();
					containers.add(container);
					contexts.put(context, containers);
				}
			}
		}
		for (GContainer subCnt: container.gGetSubContainers())
		{
			populatePostBuildContexts(subCnt, contexts);
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * eu.cessar.ct.runtime.ecuc.IEcucModel#getSplitedModuleCfgsFromSameFamily(gautosar.gecucparameterdef.GModuleDef)
	 */
	public Map<GModuleDef, Map<String, List<GModuleConfiguration>>> getSplitedModuleCfgsFromSameFamily(
		GModuleDef moduleDef)
	{
		Map<GModuleDef, Map<String, List<GModuleConfiguration>>> result = new HashMap<GModuleDef, Map<String, List<GModuleConfiguration>>>();

		List<GModuleDef> refinedModuleDefsFamily = getRefinedModuleDefsFamily(moduleDef);
		for (GModuleDef moduleDefTemp: refinedModuleDefsFamily)
		{
			Map<String, List<GModuleConfiguration>> splitedModuleCfgs = getSplitedModuleCfgs(moduleDefTemp);

			// add entry in the map only if the module definition has
			// module configuration(s)
			if (splitedModuleCfgs.size() > 0)
			{
				result.put(moduleDefTemp, splitedModuleCfgs);
			}
		}

		return result;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getChildContainerDefs(gautosar.gecucparameterdef.GContainerDef,
	 * java.lang.String)
	 */
	public List<GContainerDef> getChildContainerDefs(GContainerDef parent, String defName)
	{
		initModel();

		List<? extends GContainerDef> subContainers;
		if (parent instanceof GParamConfContainerDef)
		{
			subContainers = ((GParamConfContainerDef) parent).gGetSubContainers();
		}
		else
		{
			subContainers = ((GChoiceContainerDef) parent).gGetChoices();
		}

		return getFilteredContainerDefs(subContainers, defName);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getChildContainerDefs(gautosar.gecucparameterdef.GModuleDef,
	 * java.lang.String)
	 */
	@Override
	public List<GContainerDef> getChildContainerDefs(GModuleDef parent, String defName)
	{
		initModel();

		return getFilteredContainerDefs(parent.gGetContainers(), defName);
	}

	/**
	 * @param containers
	 *        containers to be filtered
	 * @param name
	 *        short name by which to filter the container definitions
	 * @return list with container definitions that have the specified name (case insensitive)
	 */
	private static List<GContainerDef> getFilteredContainerDefs(List<? extends GContainerDef> containers, String name)
	{
		List<GContainerDef> res = new ArrayList<GContainerDef>();

		for (GContainerDef container: containers)
		{
			if (name.equalsIgnoreCase(container.gGetShortName()))
			{
				res.add(container);
			}
		}

		return res;

	}

	/**
	 * Combine a {@code List} of {@code IStatus}es into a single, potentially {@code MultiStatus} {@code IStatus}.
	 *
	 * @param statuses
	 *        the list of {@code IStatus}es
	 * @return the combined {@code IStatus}, OK if the list is empty
	 */
	private static IStatus combineStatuses(List<IStatus> statuses)
	{
		IStatus result = Status.OK_STATUS;

		if (!statuses.isEmpty())
		{
			result = statuses.get(0);

			int size = statuses.size();
			if (size > 1)
			{
				for (IStatus otherStatus: statuses.subList(1, size))
				{
					result = PlatformUtils.combineStatus(result, otherStatus);
				}
			}
		}

		return result;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#getInitStatus()
	 */
	@Override
	public IStatus getInitStatus()
	{
		return combineStatuses(initPMStatus);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#recursiveDefUpdate()
	 */
	@Override
	public void recursiveDefUpdate(GContainer container, GModuleDef targetModuleDef, boolean setContainerDef)
	{
		EList<GParameterValue> gGetParameterValues = container.gGetParameterValues();
		for (GParameterValue gParameterValue: gGetParameterValues)
		{
			GConfigParameter parameterDefinition = gParameterValue.gGetDefinition();
			gParameterValue.gSetDefinition(getRefinedParameterDefFamily(targetModuleDef, parameterDefinition));
		}
		EList<GConfigReferenceValue> gGetReferenceValues = container.gGetReferenceValues();
		for (GConfigReferenceValue gConfigReferenceValue: gGetReferenceValues)
		{
			GConfigReference refDefinition = gConfigReferenceValue.gGetDefinition();
			GConfigReference refinedReferenceDefFamily = getRefinedReferenceDefFamily(targetModuleDef, refDefinition);
			if (refinedReferenceDefFamily != null)
			{
				gConfigReferenceValue.gSetDefinition(refinedReferenceDefFamily);
			}
		}
		EList<GContainer> gGetSubContainers = container.gGetSubContainers();
		for (GContainer gContainer: gGetSubContainers)
		{
			GContainerDef refinedContainerDefFamily = getRefinedContainerDefFamily(targetModuleDef,
				gContainer.gGetDefinition());
			if (refinedContainerDefFamily != null)
			{
				gContainer.gSetDefinition(refinedContainerDefFamily);
			}
			recursiveDefUpdate(gContainer, targetModuleDef, setContainerDef);
		}
		if (setContainerDef)
		{
			GContainerDef containertDefinition = container.gGetDefinition();
			GContainerDef containerTargetDef = getRefinedContainerDefFamily(targetModuleDef, containertDefinition);
			container.gSetDefinition(containerTargetDef);
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#recursiveDefUpdate(gautosar.gecucdescription.GContainer,
	 * gautosar.gecucparameterdef.GModuleDef)
	 */
	@Override
	public void recursiveDefUpdate(GContainer container, GModuleDef targetModuleDef)
	{
		recursiveDefUpdate(container, targetModuleDef, true);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see eu.cessar.ct.runtime.ecuc.IEcucModel#recursiveRemoveReferences(gautosar.gecucdescription.GContainer,
	 * gautosar.gecucparameterdef.GModuleDef)
	 */
	@Override
	public void recursivelyRemoveReferences(GContainer container, GModuleDef targetModuleDef)
	{
		EList<GConfigReferenceValue> gGetReferenceValues = container.gGetReferenceValues();
		Iterator<GConfigReferenceValue> iterator = gGetReferenceValues.iterator();
		while (iterator.hasNext())
		{
			GConfigReferenceValue gConfigReferenceValue = iterator.next();

			GConfigReference gGetDefinition = gConfigReferenceValue.gGetDefinition();
			GConfigReference refinedReferenceDefFamily = getRefinedReferenceDefFamily(targetModuleDef, gGetDefinition);
			if (refinedReferenceDefFamily == null)
			{

				iterator.remove();
			}
		}
		EList<GContainer> gGetSubContainers = container.gGetSubContainers();
		for (GContainer gContainer: gGetSubContainers)
		{
			recursivelyRemoveReferences(gContainer, targetModuleDef);
		}
	}
}
